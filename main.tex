\documentclass{llncs}

\usepackage{macros}
\usepackage{lstcoq}
\usepackage{lstocaml}
\usepackage{mathpartir}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{stmaryrd}
\usepackage{graphics}
\usepackage{array}
\bibliographystyle{plain}
\pagestyle{plain}

\title{Mechanizing small-inversions}
% % \subtitlte{A new elimination tactic to rule them all}
\author{Pierre Boutillier \and Thomas Braibant}
\institute{Inria Paris Rocquencourt}
\begin{document}
\maketitle
\begin{abstract}
  Inductively defined relations are pervasives in the large scale
  formalizations; and many proof steps require to invert an
  hypothesis. Coq's built-in tactic ``inversion'' is made for this
  purpose, but has severe usability and efficiency issues. 
  
  We propose a inversion tactic that mechanizes the ideas behind
  the ``small inversions'' proof-trick \cite{monin} and argue that it
  builds the right elimination principle.  
\end{abstract}
\section*{Introduction}

An inductive definition is often presetend as a set of rules (called
constructors). For example, let us define \coqe{even} by the rules
\newcommand\even{\mathtt{even}}
\begin{mathpar}
\inferrule*[right=evenO] { }{\even~0}
\and  
\inferrule*[right=evenSS]{\even~n}{\even~(S~(S~n))}
\end{mathpar}
Any inhabitant of the type \coqe{even n} must be derivable from these
rules. Inverting an element of an inductive definition is the process
of finding the possible valid derivations of this element. 

Suppose that we have an hypothesis \coqe{even (S x)} for some natural
number \coqe{x}. Since \coqe{S x} cannot be equal to \coqe{0}, we see
that the only rule that may have been apply is the constructor
\texttt{evenSS} hence \coqe{x} is equal to some \coqe{S y} and
\coqe{even y} holds. This corresponds exactly to a case analysis on
the derivations of \coqe{even n} knowing that \coqe{n} must be
matching the pattern \coqe{S x}. 

This is conceptually simple, but the inversion algorithm~\cite{cornes}
implemented in the \coqe{inversion} tactic in such a goal yields a
contrived and big proof term. A concrete manifestation of this problem
for the user is that the proof context becomes cluttered with
seemingly useless equalities, that need to be substituted away by the
user. The mantra \coqe{inversion H; clear H; subst} is both well-known
and despised by long-time Coq users.
 
Monin \cite{monin} described a new technique to build inversion
principle that solves part of the problems of inversion. The idea is
to use dependent pattern matching on the arguments of the inductive
(\coqe{S x} in the above example) to rule out impossible cases, using
a well-crafted ``diagonalization function'' (\coqe{diag} in the
following). Then, this diagonalization function is used as a return
clause in a case analysis on \coqe{H: even (S x)}. For example, if the
conclusion of the proof goal is \coqe{even (pred x)}, we may build the
proof term on Fig.\ref{fig:proof-term}. 

\begin{figure}
  \centering

\begin{multicols}{2}
\begin{coq}
let diag n := 
  match n return Prop with
  | 0 => True
  | S x =>  even (pred x)
  end in
match H as H' in even n' return diag n' 
with 
| eO => I  
| eSS k Hk => _ : even (pred (S k)) end. 
\end{coq}
\end{multicols}
\caption{Proof term for \coqe{even (S x) -> even (pred x)}}
  \label{fig:proof-term}
\end{figure}

We will come back on the precise rules that define the typing of such
dependent elimination in \secref{dependent-pattern-matching}; for the
time being, let's just recall that the return clause %
\coqe{as H' in even n' return diag n'} is a function that binds the arguments of
the inductive (\coqe{S x} as \coqe{n'}), and \coqe{H'} of type
\coqe{even n'}, and which body is the return part. Usually, the return
part is a constant (e.g., \coqe{nat} for the match in the definition
of \coqe{List.length}), but it is not mandatory. In the most general
case, the body part may depend arbitrarily on the type of the
discriminee.
%
Applying Coq's typing rules for the dependent elimination, we get the following types \begin{center}
  \begin{tabular}{l@{\quad}cc}
     & type & type (after reduction) \\
     \hline
    whole match 
    & \lstinline[language=Coq, basicstyle=\normalsize]|diag (S x)| 
    & \lstinline[language=Coq, basicstyle=\normalsize]|even (pred x)| \\
    
    first branch 
    & \lstinline[language=Coq, basicstyle=\normalsize]|diag 0|
    & \lstinline[language=Coq, basicstyle=\normalsize]|True| \\
    
    second branch 
    & \lstinline[language=Coq, basicstyle=\normalsize]|diag (S (S k))|  
    & \lstinline[language=Coq, basicstyle=\normalsize]|even k| \\
\end{tabular}
\end{center}
%
Note that the types in both columns are convertible, we just applied Coq's reduction rules to get the right-hand side column.
%
Looking at these type in order, we see first that the type of the whole match corresponds to the conclusion of the goal, making the whole proof term well-typed.
%
Then, we see that this return clause ``eliminates''the impossible branch \coqe{eO}: the type of this branch is the trivial return type \coqe{True} which is inhabited by \coqe{I}.
%
Finally, we see that the type of the second branch corresponds to the type of the hypothesis \coqe{Hk}, which allows the user to conclude the proof by filling the hole. 


\subsubsection{Contributions of the paper.} 
In their inspiring paper, Monin and Shi~\cite{monin-shi} described the
process of the creation of those diagonalization functions and state
that:
\begin{quote}
  \em ``[Their] goal is more modest: providing a hand-crafted inversion technique which is flexible enough for the user'' \end{quote} 
%
Indeed, what they provide is a general technique to craft inversions
schemes by hand.  In this paper, we report on the mechanization of the
construction of such diagonalization functions, yielding a new Coq
tactic for inversion called \coqe{invert}.

In the following of the paper, we first introduce some definitions and
notations (see \secref{sec:preliminaries}).
%
Then, we identify a well-defined set of inversions problems that can
be solved without introducing any equalities between terms making
maximal use of the expressive power of the return clauses (see
\secref{}).
%
Then, we proceed to relax the restrictions we impose on inversions
problems to tackle the general case of the problem (see \secref{}).
%
Then, we propose a comparison of the behavior of our new \coqe{invert}
tactic w.r.t. the existing elimination tactics of Coq; and evaluate
its usefulness on practical examples (see \secref{}).
%
Finally, we conclude with a comparison with related works and some
perspectives. 

\section{Preliminaries}\label{sec:preliminaries}
In this section, we define the notations and vocabulary we shall use
through the rest of the paper. Here, we settle in the context of the
Coq proof assistant, but we argue that our work could be adapted to
the context of other proof assistants based on type theory, such as
Matita or Agda.

First, we let $S$ range over sorts; that is, $S \in \set{\tt Prop,
  Set, Type_{i \in \mathbb{N}}}$ and the meta variable $t$ denote
arbitrary Coq terms. 
%
% \renewcommand\vec[1]{\overrightarrow{#1}} 
%
A Coq inductive definition has the following most general form
\begin{coq}
Inductive name $(z_1: P_1) \dots (z_p: P_p)$ : forall $(a_1:A_1) \dots (a_n:A_n), S$ :=
| $c_1$ : forall $(x^1: \alpha^1_1) \dots (x^{c_1} : \alpha^{c_1}_1)$, name $z_1 \dots z_p$ $t^1_1 \dots t^n_1$
$\vdots$
| $c_m$ : forall $(x^1: \alpha^1_m) \dots (x^{c_m} : \alpha^{c_m}_m)$, name $z_1 \dots z_p$ $t^1_m \dots t^n_m$
\end{coq}
%
First, the inductive definition \coqe{name} has $p$ parameters
$P_1;\dots;P_p$ and $n$ arguments $A_1; \dots;A_n$. We let $A$ denote
the type
%
\coqe{forall $(a_1:A_1) \dots (a_n:A_n), S$}, which is called the
arity of the inductive. We let $C_i$ denote the type of the $i$-th constructor $c_i$ of \coqe{name}
%
\begin{center}
  $C_i \eqdef$ \coqe{forall $(x^1: \alpha^1_i) \dots (x^{c_i} : \alpha^{c_i}_i)$, name $z_1 \dots z_p$ $t^1_i \dots t^n_i$}
\end{center}
where each $t_i^k$ has type $A_k$.
%
(For the sake of simplicity, we will only consider inductive without
parameters in the following; yet, our algorithms and tactic extend to
the general case.)

Then, we turn to the elimination of these inductives definitions.
Internally, Coq represents a \coqe{match} construct using a more
primitive \coqe{case} construct that takes as arguments the term that
is eliminated $e$, a return clause $R$ and one function $f_i$ per
constructor $c_i$ of the inductive (each $f_i$ corresponds to a
\emph{branch} of the case construct).  The typing rule is expressed as
follows, where the judgement $\Gamma \vdash e : \tau$ reads ``under
typing context $\Gamma$, the expression $e$ has type $\tau$.

\begin{mathpar}
\inferrule*[right=$(\dagger)$]{\Gamma \vdash e : \texttt{name}~u_1\dots u_n \and 
  \Gamma \vdash R : \forall (a_1:A_1) \dots (a_n:A_n) (H: \texttt{name}~a_1\dots a_n), S' 
  \\ \Gamma \vdash f_i : \forall (x^1: \alpha^1_i) \dots (x^{c_i} : \alpha^{c_i}_i), R~t^1_i~\dots~t^n_i (c_i~t^1_i~\dots~t^n_i) \quad i \in \set{1,\dots,m}}
{\Gamma \vdash {\tt case}~R~e~(f_1,\dots,f_n) : R~u_1\dots u_n e} 
\end{mathpar}


(Remark that the sole differences w.r.t. the (user-level) \coqe{match}
syntax are that:
%
(1) the return clause summarizes the \coqe{as ... in ... return ...}
part of the \coqe{match};
%
(2) there is no implicit binders for the arguments of the constructors
in the branches.)

\newcommand\figref[1]{Fig.\ref{#1}}

Let's take an example to clarify these notations. The various elements
of the \coqe{case} construct that corresponds to the \coqe{match} on
the right-hand side of \figref{fig:proof-term} are defined as follows:
\begin{center}
  \begin{tabular}{c@{$\quad\eqdef\quad$}l}
    $e$ & \lstinline[language=Coq, basicstyle=\normalsize]|H| \\
    $R$ & \lstinline[language=Coq, basicstyle=\normalsize]|fun (n' : nat) (H' : even n') => diag n'| \\
    $f_1$ & \lstinline[language=Coq, basicstyle=\normalsize]|I : R 0 eO| \\
    $f_2$ & \lstinline[language=Coq, basicstyle=\normalsize]|fun (k: nat) (Hk: even k) => (_ : R (S (S k)) (eSS k Hk))|
  \end{tabular}
\end{center}
Again, after applying the reduction rules, we have 
\begin{center}
  \begin{tabular}{c@{$\quad\equiv\quad$}l}
    $f_1$ & \lstinline[language=Coq, basicstyle=\normalsize]|I : True| \\
    $f_2$ & \lstinline[language=Coq, basicstyle=\normalsize]|fun (k: nat) (Hk: even k) => (_ : even k)|
  \end{tabular}
\end{center}

\subsubsection{Commutative cuts.}
Let's pause to remark that the typing rule $\dagger$ does not refine
the typing context in the type of the branches. This is the cause of a
frequent problem that we are going to illustrate on an (simplified)
example.

  First, we define the inductive \coqe{fin n}, the type with
\coqe{n} inhabitants.
\begin{coq}
Inductive fin : nat -> Type :=
| F0 : forall {n}, fin (S n)  (* n is an implicit argument for F0 *)
| FS : forall n, fin n -> fin (S n).
\end{coq}
Then, we may try to define the less-or-equal test between two
inhabitants of a given \coqe{fin n}.
\begin{coq}
Fixpoint leb n f1 f2 : bool :=
match f1 as _ in fin m return bool with 
  | F0 => true  
  | FS m1 f1' => match f2  with | F0 => false | FS m2 f2' => leb m1 f1' f2' end 
end. (* ill-typed! *)
\end{coq}
At this point, Coq complains that the term \coqe{leb _ f1' f2'} is
ill-typed. Indeed, \coqe{f1'} has type \coqe{fin m1} and \coqe{f2'}
has type \coqe{fin m2}. What happens here is that the equality between
\coqe{m1} and \coqe{m2} is not preserved: indeed, the typing rule
$\dagger$ does not modify the typing of the variables that occur in
the context.

A solution to this problem is the pattern known as \emph{commutative
  cuts}. The idea is to refine the type of a variable that occurs in
the context, by generalizing its type in the return clause, and
introducing an extra-abstraction in each branches of the match. In the
example above, the code becomes
\begin{coq}
Fixpoint leb n f1 f2 : bool :=
match f1 as _ in  fin m return fin m -> bool with 
| F0 => fun _  => true  
| FS m1 f1' => fun (f2 : fin m1 ) => 
             match f2 in fin (S m') return fin m' -> bool 
             with | F0 => fun _ => false | FS m2 f2' => fun f1' => leb _ f1' f2' end f1'
end f2.
\end{coq}
where we interleave two commutative cuts!  \marginpar{This example is
  not really good, since Coq infers part of the return clause for the
  inner match}


\section{Inversion}


\end{document}
\verb!http://pages.cs.wisc.edu/~mulhern/Mul2010/paper.pdf!

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
